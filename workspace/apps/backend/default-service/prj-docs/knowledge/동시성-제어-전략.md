# 🏯 동시성 제어 전략 (Concurrency Control Strategy)

> **Purpose**: 선착순 좌석 예약 시스템에서 발생하는 데이터 정합성 문제 해결 및 성능 최적화 전략 기록
> **Date**: 2026-02-05

## 📋 실험 기록 순서 (Progress)
1. [Step 1: 낙관적 락 (Optimistic Lock)](#step-1-낙관적-락-optimistic-lock) - **Current**
2. [Step 2: 비관적 락 (Pessimistic Lock)](#) - Pending
3. [Step 3: Redis 분산 락 (Distributed Lock)](#) - Pending

---

## Step 1: 낙관적 락 (Optimistic Lock)

### 1. 목적 (Objective)
JPA의 `@Version` 기능을 사용하여 별도의 DB 락 없이 충돌을 감지하고 데이터 정합성을 유지하는지 검증한다.

### 2. 실험 시나리오
- **테스트 코드**: `동시성_테스트_1_낙관적_락.java`
- **대상**: 1개 좌석 (Seat ID: 1)
- **부하**: 30명의 스레드가 동시에 예약 API 호출

### 3. 실험 결과 및 로그 분석

#### [수치 결과]
| 항목 | 결과값 |
| :--- | :--- |
| **성공 횟수** | 1건 |
| **실패 횟수** | 29건 |
| **최종 예약 건수** | 1건 (정합성 유지 완료) |

#### [실제 SQL 로그 증거]
첫 번째 성공한 스레드 외에는 모두 아래와 같이 `version` 조건이 일치하지 않아 실패함.

```sql
/* update for com.ticketrush.domain.concert.entity.Seat */
update seats 
set
    status='RESERVED',
    version=1  -- 버전 증가
where
    id=1 
    and version=0; -- 현재 버전이 0인 경우에만 업데이트 성공
```

#### [발생 예외]
나머지 스레드들에서는 JPA 표준 예외인 `ObjectOptimisticLockingFailureException`이 발생하며 트랜잭션이 롤백됨.

### 4. 결론 (Conclusion)
- **정합성**: 완벽하게 유지됨 (중복 예약 발생 안 함).
- **효율성**: DB 락을 걸지 않아 가볍지만, 대량의 충돌 발생 시 버려지는 요청이 너무 많음 (29/30 실패).
- **의사 결정**: 선착순 이벤트와 같이 충돌이 빈번한 경우에는 사용자에게 '재시도' 부담을 주는 낙관적 락보다는, 순차 처리를 보장하는 **비관적 락(Pessimistic Lock)** 도입이 필요함.

---
> **Next Step**: `SELECT ... FOR UPDATE`를 사용하는 비관적 락 실험 진행 예정.